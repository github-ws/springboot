
AnnotationConfigApplicationContext
	继承 GenericApplicationContext {DefaultListableBeanFactory beanFactory;}
	实现 AnnotationConfigRegistry{register（），scan（）}

DefaultListableBeanFactory{Map<String, BeanDefinition> beanDefinitionMap}
	实现ConfigurableListableBeanFactory
	实现BeanDefinitionRegistry{registerBeanDefinition（），removeBeanDefinition（），getBeanDefinition（）}

AnnotationConfigApplicationContext a=new AnnotationConfigApplicationContext();//创建spring运行环境						
	调用父类的GenericApplicationContext（）{
		this.beanFactory = new DefaultListableBeanFactory();//创建一个beanfactory包涵beanDefinitionMap属性
	}；	
	调用自己public AnnotationConfigApplicationContext() {
		this.reader = new AnnotatedBeanDefinitionReader(this);将自己spring环境传入
			//创建spring默认的BeanDefinition
			-》AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
				-》registerPostProcessor(BeanDefinitionRegistry registry, RootBeanDefinition definition, String beanName) 
					//注册bean
					-》registry.registerBeanDefinition(beanName, definition);
					相当于调用GenericApplicationContext.registerBeanDefinition（）
						-》调用DefaultListableBeanFactory.registerBeanDefinition()
					向DefaultListableBeanFactory的beanDefinitionMap属性注册bean
		this.scanner = new ClassPathBeanDefinitionScanner(this);
	}	
																	
a.register(config.class);//注册bean(注：一些注解处理在refresh中)
	reader.register(annotatedClasses);	
		-》AnnotatedBeanDefinitionReader.registerBean(annotatedClass)
		        -》doRegisterBean（annotatedClass,null,null,null）
			//将类封装成AnnotatedGenericBeanDefinition类它包含类的注解，类型等信息	
			AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
			//返回bean名字（实际调用AnnotationBeanNameGenerator.generateBeanName（））
			String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));
			//@DependsOn注解可以定义在类和方法上，意思是我这个组件要依赖于另一个组件，也就是说被依赖的组件会比该组件先实例化到IOC容器中
			依赖的bean加到AbstractBeanDefinition的this.dependsOn属性上（@DependsOn注解的自己理解）
			//处理bd的lazy.class,Primary.class,DependsOn.class属性
			AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
			//处理作用域模式
			AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
			//注册bean
			BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
				//注册bean
				registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());
				//注册别名
				String[] aliases = definitionHolder.getAliases();
				if (aliases != null) {
					for (String alias : aliases) {
						registry.registerAlias(beanName, alias);
					}
				}

a.refresh();//刷新，构建spring,   new bean，注入属性
	//环境准备
	prepareRefresh();
	//获取bean工厂
	ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
	//bean工厂准备，注册一些处理器，设置一些属性
	prepareBeanFactory(beanFactory);
	//空方法，应该是供子类扩展
	postProcessBeanFactory(beanFactory);	
	//在上下文中调用注册为bean的工厂处理器
	invokeBeanFactoryPostProcessors(beanFactory);
		//getBeanFactoryPostProcessors()获取要处理的BeanFactoryPostProcessors（没试出来什么时候会有值）
		         是 List<BeanFactoryPostProcessor> beanFactoryPostProcessors是AbstractApplicationContext属性
		--》PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
			//获取容器内所有BeanDefinitionRegistryPostProcessor
			beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
			//创建实例加入到集合中
			currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
			//调用BeanDefinitionRegistryPostProcessor处理器
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			//处理BeanFactoryPostProcessor和上面一样
			beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);
			。。。。。
			故先执行BeanDefinitionRegistryPostProcessor逻辑再处理 BeanFactoryPostProcessor,
			所以可以在BeanDefinitionRegistryPostProcessor中扩展BeanFactoryPostProcessor,即在注册几个BeanFactoryPostProcessor

		ConfigurationClassPostProcessor一个系统默认的Configuration类处理器（处理完后会将扫秒到的类加入spring bdmap）
			ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry（registry）
				-》processConfigBeanDefinitions(BeanDefinitionRegistry registry)
				//获取bean的名字
				String[] candidateNames = registry.getBeanDefinitionNames();
				//循环处理
				for (String beanName : candidateNames) {	
					//判断处理过没有
					if(){				
					//判断加沒加注解
				 	}else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {
						//上面的判断方法
					                checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)
						//判断加沒加Configuration注解
						--》isFullConfigurationCandidate(metadata)
						                  beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
						//判断加沒加candidateIndicators.add(ComponentScan.class.getName());
							  candidateIndicators.add(Import.class.getName());
							  candidateIndicators.add(ImportResource.class.getName());
						--》isLiteConfigurationCandidate
							beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
						//加入集合
						configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));
					}
				//处理Configuration类集合
				-》ConfigurationClassParser.parse(candidates);
					//注册bean,@ComponentScan,@Import ,@Bean methods等注解扫描到的，
					处理@import时会判断是ImportBeanDefinitionRegistrar.class,ImportSelector.class和其它类等
					所以可以实现ImportBeanDefinitionRegistrar扩展自定义bean
					--》doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)	         
	//创建spring bean的后置处理器
	registerBeanPostProcessors(beanFactory);
		-》BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);//创建
			-》beanFactory.addBeanPostProcessor(postProcessor);//添加到集合中
	//国际化资源初始化
	initMessageSource();
	//初始化事件派发器SimpleApplicationEventMulticaster 
	initApplicationEventMulticaster（）
	//空方法，也是供子类实现的（网上说springboot启动tomcat是重写了这个方法）
	onRefresh();
	//注册监听器到前面初始化好的派发器上面去，；
	registerListeners（）  注：我们自己的监听器初始化是在finishBeanFactoryInitialization方法中
		//首先获取容器中已有的监听器注册到派发器
		for (ApplicationListener<?> listener : getApplicationListeners()) {
			getApplicationEventMulticaster().addApplicationListener(listener);
		}
		//然后获取bean定义中的监听器，也就是我们自己定义的监听器
		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
		for (String listenerBeanName : listenerBeanNames) {
			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
		}
		//发布早期事件
		Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
		this.earlyApplicationEvents = null;
		if (earlyEventsToProcess != null) {
			for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
				getApplicationEventMulticaster().multicastEvent(earlyEvent);
			}
		}
	//创建bean注入属性（难的一比）
	finishBeanFactoryInitialization(beanFactory);
		//初始化non-lazy的bean
		-》beanFactory.preInstantiateSingletons() (是DefaultListableBeanFactory的方法)
			//获取bean名字循环处理
			-》List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);
			//判断不是抽象类，是单例，不懒加载
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
					Object bean = getBean( beanName);
					......处理factorybean逻辑
				}else{
					Object bean = getBean( beanName);
				}
			}
	//容器启动完成最后刷新
	finishRefresh();
		调用publishEvent(new ContextRefreshedEvent(this));处理一个完成刷新事件
	注：我们可以手动调用容器的publishEvent方法发布事件

获取bean
getBean（name）逻辑：
	调用AbstractBeanFactory.doGetBean(name, null, null, false)
		//获取bean名称，主要处理别名，&获取原对象
		transformedBeanName(name)；
		//从缓存中获取，即查一，二，三级缓存,  spring用了三级缓存处理单例类能解决循环依赖，但构造器的循环依赖，多实例Bean依赖会报循环依赖异常
		1，第一级缓存：singletonObjects存放完全实例化属性赋值完成的Bean。
		2，第二级缓存：earlySingletonObjects存放早期Bean的引用，尚未属性装配的Bean。
		3，第三级缓存：singletonFactories存放实例化完成的Bean工厂。（为了处理代理模式，如果是代理的话，应该返回的是代理对象，而代理在初始化后面创建）
	 	Object sharedInstance=getSingleton(String beanName, boolean allowEarlyReference) 
		如果不为null,Factorybean类型处理然后返回bean
			bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
		为null	
			//将this.alreadyCreated.add(beanName);表示bean已处理
			调用markBeanAsCreated(beanName);
			//获取依赖的bean先初始化（我感觉是@DependsOn注解标识的）
			String[] dependsOn = mbd.getDependsOn();
			//创建bean
			sharedInstance = getSingleton(beanName, () -> {
				try {
					return createBean(beanName, mbd, args);
				}}
			上一步实际调用DefaultSingletonBeanRegistry.getSingleton(String beanName, ObjectFactory<?> singletonFactory) 
				-》singletonObject = singletonFactory.getObject();
				实际调用AbstractAutowireCapableBeanFactory.createBean(String beanName, RootBeanDefinition mbd, null)
					//调用一些特殊的BeanPostFactory(如Aop代理注解的处理)
					-》Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
						->(bp instanceof InstantiationAwareBeanPostProcessor
						     bp.postProcessBeforeInstantiation(beanClass, beanName)
							//判断解析@Aspect，并储存起来
							AbstractAutoProxyCreator.postProcessBeforeInstantiation(Class<?> beanClass, String beanName) 
						    	       -》AspectJAwareAdvisorAutoProxyCreator.shouldSkip(Class<?> beanClass, String beanName) 
								调AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors()
								调BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors()
								调(AnnotationUtils.findAnnotation(clazz, Aspect.class) != null);
					-》Object beanInstance = doCreateBean(beanName, mbdToUse, args);	
					//返回实例
					调用instanceWrapper=createBeanInstance(beanName, mbd, args);//反射拿到Class对象
					 // 创建对象成功时，把对象缓存到singletonFactories缓存中
					addSingletonFactory();
					// 依赖注入的核心方法，如果引入其它bean,就调用getBean()
					populateBean(beanName, mbd, instanceWrapper);
						-》调用AutowiredAnnotationBeanPostProcessor后置处理器的postProcessProperties
					// bean 实例化ioc依赖注入完以后的调用
					exposedObject = initializeBean(beanName, exposedObject, mbd);
						-》invokeAwareMethods(beanName, bean);
						    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
						    invokeInitMethods(beanName, wrappedBean, mbd);
						    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
							//处理Aop，生成代理对象
							->AbstractAutoProxyCreator.postProcessAfterInitialization(Object bean, String beanName)
								//创建jdk或cglib代理配置类
								-》DefaultAopProxyFactory.createAopProxy(AdvisedSupport config)
									-》 getProxy();生成代理对象
				//加入缓存
				addSingleton(beanName, singletonObject);
		              					
spring提供的常用扩展点：
	BeanFactory后置处理器：
		BeanFactoryPostProcessor（后执行）
		BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor先执行
	Bean后置处理器，初始化前后调用:(初始化是指创建bean实例以后的初始化操作)
		BeanPostProcessor：有前后两个方法postProcessBeforeInitialization，postProcessAfterInitialization
		（个人感觉有一些特殊的BeanPostFactory后置处理器,虽然也是BeanPostFactory的子类，
			但也继承InstantiationAwareBeanPostProcessorAdapter等其它类，判断时调用的是子类的方法
			如AutowiredAnnotationBeanPostProcessor属性注入时，虽然获取的是BeanPostFactory，但是判断的是都是其它类的实例，	
			最后调用ibp.postProcessProperties（）方法，并不是postProcessBeforeInitialization，postProcessAfterInitialization
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
				}
			}
		 ）
	FactoryBean:
		返回处理后bean类型相当于转换bean，可以使用 FactoryBean 创建一些实例化过程比较复杂的bean
		注意可以通过&加bean的名字获取原bean
	Aware接口：主要用于给对象注入某个属性的值
		BeanNameAware 实现setBeanName()方法，修改bean的name
		ApplicationContextAware 实现setApplicationContext() 可以为bean注入上下文对象ApplicationContext
		BeanFactoryAware 实现setBeanFactory()，可以注入容器工厂
		......
	InitializingBean：
		实现InitializingBean的afterPropertiesSet()方法在AbstractAutowireCapableBeanFactory#initializeBean()中调用
	DisposableBean:
		实现DisposableBean的destroy方法,销毁时调用
	事件监听器：
		spring容器提供派发器	SimpleApplicationEventMulticaster（容器初始化自动注入）
		用户实现ApplicationListener<T>然后注册进spring，是事件监听器
		用户继承ApplicationEvent编写自定义事件，然后使用context.publishEvent(new MyApplicationEvent(“”))发布事件
		流程是context.publishEvent（）会调用SimpleApplicationEventMulticaster.multicastEvent（event）
			获得getApplicationListeners（）得到监听器在调用监听器的onApplicationEvent（）		
		注意会根据事件类型去判断监听器的T泛型获取对应的监听器
@PostConstruct是java中的注解，Spring实现了它，所以在Spring项目中使用@PostConstruct注解的方法在构造函数和依赖注入后会执行

1，首先执行bean的构造方法,
2，BeanPostProcessor的postProcessBeforeInitialization方法
3，InitializingBean的afterPropertiesSet方法
4，@Bean注解的initMethod方法
5，BeanPostProcessor的postProcessAfterInitialization方法
spring.close（）调用
6，DisposableBean的destroy方法
7，@Bean注解的destroyMethod方法

一些注解
	@import
    		声明一个bean
    		导入@Configuration注解的配置类
    		导入ImportSelector的实现类(需要自己写返回类名称)
    		导入ImportBeanDefinitionRegistrar的实现类(可以自己定义注册bd)
	@ConditionalOnBean（仅仅在当前spring中存在某个对象时，才会实例化一个Bean）
	@ConditionalOnClass（某个class位于类路径上，才会实例化一个Bean）
	@ConditionalOnExpression（当表达式为true的时候，才会实例化一个Bean）
	@ConditionalOnMissingBean（仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean）
	@ConditionalOnMissingClass（某个class类路径上不存在的时候，才会实例化一个Bean）
	@ConditionalOnNotWebApplication（不是web应用）

springmvc 
	DispacterServlet初始化，用HandlerMapping找到合适的处理器（默认有两个分别处理Bean的形式即implements Controller的和注解的），
		HandlerAdapter适配HandlerMapping返回相应的处理方式
springboot 
	websocket实现方式（可以去官网下例子）
		1自定义WebSocketServer，使用底层的websocket方法，提供对应的onOpen、onClose、onMessage、onError方法.
		2基于STOMP协议的WebSocket，STOMP的好处在于，它完全就是一种消息队列模式
servlet3.0新特性
	提供了@WebServlet 用于将一个类声明为 Servlet，该注解将会在部署时被容器处理
		eg: @WebServlet(urlPatterns = {"/simple"}, asyncSupported = true,
		loadOnStartup = -1, name = "SimpleServlet", displayName = "ss",
		initParams = {@WebInitParam(name = "key", value = "value")}
	   	)
	          @WebInitParam该注解通常不单独使用，而是配合 @WebServlet 或者 @WebFilter 使用。它的作用是为 Servlet 或者过滤器指定初始化参数
	          @WebFilter 用于将一个类声明为过滤器，该注解将会在部署时被容器处理
		eg: @WebFilter(servletNames = {"SimpleServlet"},filterName="SimpleFilter")
	          @WebListener该注解用于将类声明为监听器	           
	        ServletContainerInitializer接口也是 Servlet 3.0 新增的一个接口，
		Servlet容器启动会扫描当前应用里面ServletContainerInitializer的实现类。
		实现类必须绑定在类路径的META-INF/services/javax.servlet.ServletContainerInitializer的文件中，文件的内容就是实现类的全类名。
		调用该类的 onStartup() ，在该实现类上使用 @HandlesTypes 注解来指定希望被处理的类，容器会把指定的这个类型的子类传递给onStartup方法。


小问题：
      SQL 行转列，列转行
	行转列    SELECT id,MAX(CASE WHEN col1='条件1' THEN col2 ELSE 0  END) AS "",MAX(CASE WHEN col1='条件1' THEN col2 ELSE 0  END) AS "" 
			FROM table GROUP BY id
                列转行    SELECT id,MAX(col) AS "" FROM table GROUP BY id
			UNION SELECT id,MAX(col2) AS "" FROM table GROUP BY id

      mybatis主键回显
      在<insert>标签中添加keyProperty=“主键字段”,useGeneratedKeys=”true”
       	keyProperty：表示指定的属性作为主键, useGeneratedKeys：如果为true，mybatis使用Jdbc的getGeneratedKeys()的方法来获取数据库内部生成得到主键（我猜的）


spring微服务：
        分布式系统有三个指标CAP,Consistency   ---一致性， Availability   ---可用性，Partition tolerance  ---分区容错性
        spring cloud部署：
	服务端@EnableEurekaServer
		server:
		 port: 8001

		eureka:
		  instance:
		    instance-id: eurika-001 #此实例注册到eureka服务端的唯一的实例ID
		    hostname: eurika001 #感觉要填真实主机名，集群用的
		  server:
		    enable-self-preservation: true  #关闭自我保护机制
		    eviction-interval-timer-in-ms: 60000 #设置无效服务清理间隔（单位：毫秒 默认是60*1000）
		  client:
		    registerWithEureka: true #false不把自己作为一个客户端注册到自己身上
		    serviceUrl:
		      defaultZone: http://eurika002:8002/eureka #服务注册地址，也是DS Replicas主机名（集群填其它服务器地址，服务器之间可相互注册）

		spring:
		  application:
		    name: eurika #项目名，此实例注册到eureka服务端的name

	客户端@EnableEurekaClient	
		server:
		  port: 7002
		eureka:
		  client:
		    serviceUrl:
		      defaultZone: http://eurika002:8002/eureka/,http://eurika001:8001/eureka/  #eureka服务端提供的注册地址 参考服务端配置的这个路径
		  instance:
		    instance-id: Service002 #此实例注册到eureka服务端的唯一的实例ID
		    prefer-ip-address: true #是否显示IP地址
		    leaseRenewalIntervalInSeconds: 10 #eureka客户需要多长时间发送心跳给eureka服务器，表明它仍然活着,默认为30 秒 (与下面配置的单位都是秒)
		    leaseExpirationDurationInSeconds: 30 #Eureka服务器在接收到实例的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认为90秒

		spring:
		  application:
		    name: server #项目名，此实例注册到eureka服务端的name
	负载均衡ribbon
		 @Bean
   		 @LoadBalanced
    		public RestTemplate restTemplate(){
       			 return new RestTemplate();
    		}
		Feign在此基础上做了进一步封装可以简化开发，由他来帮助我们定义和实现服务接口的定义
@FeignClient("server")
public interface ServiceClient {
    @RequestMapping("/get")
    public Object get();
}
在启动类上面加上注解:@EnableFeignClients，就可以直接使用了

Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，
不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性
熔断机制是应对雪崩效应的一种微服务链路保护机制，当链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用
在启动类上面加上注解@EnableHystrix，接口上加fallback属性，ym加feign: hystrix: enabled: true
服务降级
@Component
public class ServiceFallBack implements ServiceClient {
    @Override
    public String get() {
        return "liangliang";
    }
}
常用配置
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 命令执行超时时 间，默认1000ms
hystrix.command.default.execution.timeout.enabled 执行是否启用超时，默认启用true
hystrix.command.default.execution.isolation.thread.interruptOnTimeout 发生超时是是否中断， 默认true
服务熔断
//滑动窗口的大小，默认为20
circuitBreaker.requestVolumeThreshold 
//过多长时间，熔断器再次检测是否开启，默认为5000，即5s
circuitBreaker.sleepWindowInMilliseconds 
//错误率，默认50%
circuitBreaker.errorThresholdPercentage
每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。直到5s后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开